<div class="guideContainer">
  <h1>Concept Guide: Strings and Arrays</h1>
  <h2>Arrays</h2>
  <p>
    An array is a data structure that holds an ordered collection of objects.
    They are indexed, making them highly efficient for lookup operations. The
    items are mutable; they can be updated or deleted. Arrays can hold any data
    type.
  </p>
  <p>
    A standard array is a fixed length that can hold only one data type. This is
    the default for most object-oriented programming languages. Python instead
    defaults to lists. The length of lists is mutable and does not need to be
    declared ahead of time. You can append data as needed any time. While not
    recommended, a list can also contain a mix of types. This flexibility has
    many advantages.
  </p>

  <p><strong>Python implementation</strong></p>
  <pre><code class="codeBlock"># Create an empty list
my_list = []

# Add an item to the list
my_list.append(1)

# Add multiple items to the list
my_list.extend([2, 3, 4])

# Access an item in the list
print(my_list[0])  # Output: 1

# Update an item in the list
my_list[0] = 5

# Delete an item from the list
del my_list[0]

# get a sublist
sublist = my_list[1:3]

# concatenate lists
my_list += [6, 7]

# get the length of the list
print(len(my_list))  # Output: 5
  </code></pre>

  <h2>Strings</h2>
  <p>
    A string is a sequence of characters. Strings are immutable, meaning they
    cannot be changed after they are created. This is because strings are
    implemented as arrays of characters. To change a string, you must create a
    new one. To avoid creating a new copy, in Python, you can represent a string
    as a list of characters and operate on the list of characters instead.
    Strings are indexed starting at 0.
  </p>

  <p><strong>String Vocabulary</strong></p>
  <ul>
    <li>
      <strong>Substring:</strong> A contiguous sequence of characters within a
      string. For example, in <code>"hello"</code>, <code>"ell"</code> is a
      substring.
    </li>
    <li>
      <strong>Prefix:</strong> A substring that appears at the beginning of a
      string. For example, in <code>"hello"</code>, <code>"he"</code> is a
      prefix.
    </li>
    <li>
      <strong>Suffix:</strong> A substring that appears at the end of a string.
      For example, in <code>"hello"</code>, <code>"lo"</code> is a suffix.
    </li>
    <li>
      <strong>Lexicographical Order:</strong> The order in which words are
      listed in a dictionary. For example, "apple" comes before "banana" in
      lexicographical order.
    </li>
    <li>
      <strong>Palindrome:</strong> A string that reads the same forwards and
      backwards.
    </li>
    <li>
      <strong>Anagram:</strong> A word or phrase formed by rearranging the
      letters of a different word or phrase.
    </li>
  </ul>
  <p>
    A subarray and subsequence of an array have the same definition, but with
    the objects in the array.
  </p>

  <p><strong>Python implementation</strong></p>
  <pre><code class="codeBlock"># Create a string
my_string = "hello"

# Access a character in the string
print(my_string[0])  # Output: h

# get a substring (slicing)
substring = my_string[1:3] # Output: "el"

# concatenate strings
my_string += " world"

# convert a string to a list of characters
char_list = list(my_string)

# convert a string to lowercase
lowercase_string = my_string.lower()
  </code></pre>

  <p>
    There are many more common string methods useful for technical interviews.
    Be sure to familiarize yourself with them. An additional library to learn
    regex <code>re</code> module. This is a way to manipulate substrings using
    regular expression patterns. expression patterns.
  </p>

  <h2>Time Complexity</h2>
  <p>
    <strong>Accessing an item:</strong> Python lists and strings are indexed.
    Accessing an item by its index takes O(1) time.
  </p>

  <p>
    <strong>Insertion and deletion:</strong>
  </p>
  <p>
    Inserting or deleting at the end of a list takes O(1) with a simple append.
    However, to insert or delete at the beginning of the list or elsewhere,
    every other other item following it must move by one index. This takes O(n)
    time.
  </p>
  <p>
    Inserting or deleting in a string takes O(n) time because a new string must
    be created. Every character following the insertion or deletion must be
    copied to the new string. This applies to string concatenation as well.
  </p>

  <h2>Common Strategies</h2>
  <p>
    These first two strategies have been introduced in earlier lessons and are
    also valuable for strings and arrays problems.
  </p>
  <p><strong>Two Pointer Method</strong></p>
  <p>
    The two-pointer technique can help you reference two locations of the array
    at the same time. The pointers can move in the same direction or in opposite
    directions. This method is useful for problems where you need to compare
    elements in an array or string. A common example is checking if a string is
    a palindrome by placing a pointer at either end of the string. The strategy
    also applies to using pointers on two separate arrays or strings. Using two
    pointers can often help you avoid using additional storage.
  </p>
  <p><strong>Hash table</strong></p>
  <p>
    Hash tables and hash sets are also useful for string and array problems.
    Hash tables are useful for counting the frequency of elements, store
    pre-computation values, or subsequences in an array or string. They are also
    useful for checking if an element exists in an array or string. Keep in mind
    that an array can simulate a hash table by using the index as a key. This
    may be a simpler solution for some problems.
  </p>
  <p><strong>Sliding Window Method</strong></p>
  <p>
    The sliding window technique is useful for problems where you need to
    maintain a subset of the array or string. It is a specific implementation of
    the two-pointer technique. The window is a range of elements that moves
    through the array or string, bounded by the pointers. This method is useful
    for problems where you need to find a subset of elements that satisfy a
    specific condition with low time complexity. The window can be a fixed size
    or variable size. The window can slide in one direction or both directions.
  </p>
  <p><strong>Sorting the array</strong></p>
  <p>
    Sorting an array can be a useful strategy for many problems. Python’s
    in-built sorting methods are time efficient (O(n log n)) and can help
    drastically simplify a problem. It can help you find duplicates, find the
    median, or find the kth largest element. Further, consider if an array is
    already sorted. For example, a partially sorted array could be sorted using
    a modified binary sort. Do not sort the array when the order of the elements
    needs to be maintained. For example, when asked to identify a subarray.
  </p>
  <p><strong>Multiple Traversals</strong></p>
  <p>
    Sometimes, you may need to traverse an array or string multiple times to
    solve a problem. This is a common strategy when you need to compare elements
    or find a specific element. Be sure to consider the time complexity of
    multiple traversals. Traversing an array multiple times can help keep your
    time complexity to O(n).
  </p>
  <p><strong>Traverse from the right</strong></p>
  <p>
    This is a simple strategy that can help you consider alternative solutions.
    When you are stuck, try traversing the array or string from the right. This
    strategy is good for problems like finding the last element that satisfies a
    condition.
  </p>
  <p><strong>Pre-computation</strong></p>
  <p>
    Pre-computation is a strategy where you calculate values ahead of time to
    reduce the time complexity of your solution. This is useful when you need to
    calculate the sum of elements, the frequency of elements, or the maximum or
    minimum value. Consider using a hash table or array to store these values.
  </p>

  <h2>Common Errors</h2>
  <p>
    If you are running into bugs or unexpected outputs, make sure you have
    considered the following cases.
  </p>
  <ul>
    <li>Off-by-one errors due to improper indexing</li>
    <li>Accessing out-of-bound indexes</li>
    <li>Empty array or string corner case</li>
    <li>Presence of duplicate values</li>
    <li>Incorrectly updating pointers</li>
  </ul>

  <h2>Key Takeaways</h2>
  <ul>
    <li>
      Arrays are ordered collections of objects, indexed for efficient lookup
      operations⁠.
    </li>
    <li>
      Standard arrays have fixed length and hold one data type, while Python
      lists are mutable and can contain mixed types⁠
    </li>
    <li>
      Strings are sequences of characters, immutable, and indexed starting at 0⁠
    </li>
    <li>
      Accessing elements by index is O(1) while other operations like insertion,
      searching, and deletion is O(n)
    </li>
    <li>
      Common strategies for strings and arrays include the two-pointer method, hash
      tables, sliding window method, and sorting.
    </li>
  </ul>
</div>
