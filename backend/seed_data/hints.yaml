hints:
  # Hash maps
  - module_type: "CHALLENGE"
    module_title: "Contains Duplicate"
    hints:
      - text: "It does not matter what the duplicate is, only that one exists."
        order: 1
      - text: "A hash set could be useful."
        order: 2

  - module_type: "BONUS_CHALLENGE"
    module_title: "Longest Substring Without Repeating Characters"
    hints:
      - text: "Use two pointers to create a sliding window."
        order: 1
      - text: "Use a hash set to store the characters in the current window."
        order: 2

  # Linked Lists
  - module_type: "CHALLENGE"
    module_title: "Remove Nth Node From End of List"
    hints:
      - text: "Use two pointers with a strategic separation."
        order: 1
      - text: "Create a dummy head node to handle edge cases."
        order: 2

  - module_type: "BONUS_CHALLENGE"
    module_title: "Reverse Linked List"
    hints:
      - text: "Focus on changing the direction of links without creating a new list."
        order: 1
      - text: Consider using three pointers (prev, current, and next) to systematically reverse the list's links.
        order: 2

  # Binary Trees
  - module_type: "CHALLENGE"
    module_title: "Invert Binary Tree"
    hints:
      - text: "Use a pre-order traversal to invert the tree."
        order: 1
      - text: "Use a recursive approach to swap each node's children."
        order: 2
      - text: "Remember to handle the base case of a null node."
        order: 3

  - module_type: "BONUS_CHALLENGE"
    module_title: "Convert Sorted Array to Binary Search Tree"
    hints:
      - text: "Use the median element as the root of the tree."
        order: 1
      - text: "Use a recursive approach to build the tree."
        order: 2
      - text: "Remember to handle the base case of an empty array."
        order: 3

  # Strings and Arrays
  - module_type: "CHALLENGE"
    module_title: "Is Subsequence"
    hints:
      - text: "Use two pointers to compare the characters of the two strings."
        order: 1
      - text: "Move the pointer of s forward only when the characters match. Remember that the matching characters in t do not need to be contiguous."
        order: 2
      - text: "Return true if every character in s is matched with a character in t."
        order: 3

  - module_type: "BONUS_CHALLENGE"
    module_title: "Product of Array Except Self"
    hints:
      - text: "Use the multiple passes strategy, including traversing from the array from the right."
        order: 1
      - text: "Consider breaking down the products into smaller parts. Can you separate the numbers that come before the current index from those that come after it?"
        order: 2
      - text: "Track the running products of the numbers before and after the current index in the outcome array."
        order: 3

  # Graphs
  - module_type: "CHALLENGE"
    module_title: "Number of Islands"
    hints:
      - text: "Use depth-first search (DFS) to traverse the grid."
        order: 1
      - text: "Mark the visited cells to avoid redundant counting."
        order: 2
      - text: "Once you find a land cell, perform DFS on its neighbors to mark all connected land cells as visited."
        order: 3

  - module_type: "BONUS_CHALLENGE"
    module_title: "Max Area of Island"
    hints:
      - text: "Use depth-first search (DFS) to traverse the grid."
        order: 1
      - text: "Track the size of the current island as you explore it."
        order: 2
      - text: "Perform DFS on land cell's neighbors and sum the areas."
        order: 3